#!/usr/bin/env python3
"""
Skill Packaging Tool - Create distributable .zip after validation.

Usage:
    python package_skill.py .
    python package_skill.py path/to/skill --output-dir dist/
    python package_skill.py . --min-score 90 --force
"""

import argparse
import json
import sys
import zipfile
from pathlib import Path
from datetime import datetime
import yaml


def generate_readme(skill_path: Path) -> str:
    """Generate README.md for packaged skill."""
    skill_file = skill_path / "SKILL.md"
    content = skill_file.read_text()

    # Parse frontmatter
    frontmatter = {}
    if content.startswith("---"):
        try:
            end_idx = content.find("---", 3)
            if end_idx != -1:
                yaml_content = content[3:end_idx].strip()
                frontmatter = yaml.safe_load(yaml_content) or {}
        except Exception:
            pass

    skill_name = frontmatter.get('name', skill_path.name)
    description = frontmatter.get('description', 'No description available')
    keywords = frontmatter.get('keywords', [])
    tech_stacks = frontmatter.get('tech_stacks', [])
    version = frontmatter.get('version', '1.0.0')

    keywords_str = ", ".join(keywords) if isinstance(keywords, list) else str(keywords)
    tech_stacks_str = ", ".join(tech_stacks) if isinstance(tech_stacks, list) else str(tech_stacks)

    readme = f"""# {skill_name}

{description}

## üì¶ Package Information

- **Version**: {version}
- **Keywords**: {keywords_str}
- **Tech Stacks**: {tech_stacks_str}
- **Packaged**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üì• Installation

1. Extract this zip file to your Claude Code skills directory:
   ```bash
   unzip {skill_name}-v{version}.zip -d ~/.claude/skills/
   ```

2. Claude Code will automatically detect and load the skill.

## üéØ Usage

This skill auto-activates when you mention:
{keywords_str}

Or explicitly invoke:
```
Use {skill_name} skill to help me with [your task]
```

## üìö Contents

- **SKILL.md**: Main skill definition
- **examples/**: Complete code examples
- **templates/**: Reusable code templates
- **references/**: Detailed guides and documentation
- **checklists/**: Validation checklists

## üîç Quality Score

This skill has been validated and meets quality standards (score ‚â•95/100).

## üìÑ License

Refer to your project's license.

---

**Generated by skill-creator v2.0.0**
"""

    return readme


def package_skill(
    skill_path: Path,
    output_dir: Path,
    min_score: int = 95,
    force: bool = False,
    include_scripts: bool = False
) -> Path:
    """Package skill into .zip file."""

    skill_file = skill_path / "SKILL.md" if skill_path.is_dir() else skill_path
    skill_dir = skill_path if skill_path.is_dir() else skill_path.parent

    if not skill_file.exists():
        raise FileNotFoundError(f"SKILL.md not found at {skill_file}")

    # Validate first (unless forced)
    if not force:
        print("üîç Validating skill before packaging...")
        from validate_skill import SkillScorer
        scorer = SkillScorer(skill_path)
        result = scorer.score()

        print(f"   Score: {result['score']}/100")

        if result['score'] < min_score:
            print(f"\n‚ùå Validation failed: Score {result['score']} < {min_score}")
            print(f"\nüí° Suggestions:")
            for suggestion in result['suggestions']:
                print(f"   {suggestion}")
            print(f"\n   Use --force to package anyway (not recommended)")
            sys.exit(1)

        print(f"   ‚úÖ Passed (score >= {min_score})")

    # Parse frontmatter for version
    content = skill_file.read_text()
    frontmatter = {}
    if content.startswith("---"):
        try:
            end_idx = content.find("---", 3)
            if end_idx != -1:
                yaml_content = content[3:end_idx].strip()
                frontmatter = yaml.safe_load(yaml_content) or {}
        except Exception:
            pass

    skill_name = frontmatter.get('name', skill_dir.name)
    version = frontmatter.get('version', 'latest')

    # Generate README.md
    print("üìù Generating README.md...")
    readme_content = generate_readme(skill_path)
    readme_path = skill_dir / "AUTO_README.md"
    readme_path.write_text(readme_content)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create zip file
    zip_name = f"{skill_name}-v{version}.zip"
    zip_path = output_dir / zip_name

    print(f"üì¶ Creating package: {zip_name}")

    # Files/directories to exclude
    exclude_patterns = [
        '.DS_Store', '__pycache__', '*.pyc', '.git', '.gitignore',
        'node_modules', 'venv', '.venv', '*.log', '*.tmp',
        '*.backup'
    ]

    if not include_scripts:
        exclude_patterns.append('scripts')

    def should_exclude(path: Path) -> bool:
        """Check if file should be excluded."""
        for pattern in exclude_patterns:
            if pattern.startswith('*'):
                if path.name.endswith(pattern[1:]):
                    return True
            elif pattern in str(path):
                return True
        return False

    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        # Add all files in skill directory
        for file_path in skill_dir.rglob('*'):
            if file_path.is_file() and not should_exclude(file_path):
                arcname = file_path.relative_to(skill_dir.parent)
                zipf.write(file_path, arcname)
                print(f"   + {arcname}")

    # Get file size
    file_size = zip_path.stat().st_size
    size_kb = file_size / 1024
    size_mb = size_kb / 1024

    if size_mb >= 1:
        size_str = f"{size_mb:.2f} MB"
    else:
        size_str = f"{size_kb:.2f} KB"

    # Clean up AUTO_README.md
    readme_path.unlink()

    return zip_path, size_str


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Package skill into distributable .zip",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python package_skill.py .
  python package_skill.py path/to/skill --output-dir dist/
  python package_skill.py . --min-score 90 --force

Workflow:
  1. Validates skill (score must be >= min-score)
  2. Generates AUTO_README.md with installation instructions
  3. Creates .zip file with skill contents
  4. Excludes: .DS_Store, __pycache__, .git, scripts/, backups
        """
    )

    parser.add_argument("skill_path", help="Path to SKILL.md or skill directory")
    parser.add_argument("--output-dir", default=".", help="Output directory (default: current dir)")
    parser.add_argument("--min-score", type=int, default=95,
                       help="Minimum score required to package (default: 95)")
    parser.add_argument("--force", action="store_true",
                       help="Skip validation (not recommended)")
    parser.add_argument("--include-scripts", action="store_true",
                       help="Include scripts/ folder in package")
    parser.add_argument("--dry-run", action="store_true",
                       help="Show what would be packaged without creating .zip")

    args = parser.parse_args()

    skill_path = Path(args.skill_path)
    output_dir = Path(args.output_dir)

    try:
        if args.dry_run:
            print("üîç DRY RUN - Showing what would be packaged:\n")

            skill_dir = skill_path if skill_path.is_dir() else skill_path.parent

            exclude_patterns = [
                '.DS_Store', '__pycache__', '*.pyc', '.git', '.gitignore',
                'node_modules', 'venv', '.venv', '*.log', '*.tmp',
                '*.backup'
            ]

            if not args.include_scripts:
                exclude_patterns.append('scripts')

            def should_exclude(path: Path) -> bool:
                for pattern in exclude_patterns:
                    if pattern.startswith('*'):
                        if path.name.endswith(pattern[1:]):
                            return True
                    elif pattern in str(path):
                        return True
                return False

            for file_path in skill_dir.rglob('*'):
                if file_path.is_file() and not should_exclude(file_path):
                    print(f"   + {file_path.relative_to(skill_dir.parent)}")

            print("\n‚ÑπÔ∏è No package created (dry run)")
            sys.exit(0)

        # Package skill
        zip_path, size_str = package_skill(
            skill_path=skill_path,
            output_dir=output_dir,
            min_score=args.min_score,
            force=args.force,
            include_scripts=args.include_scripts
        )

        print(f"\n‚úÖ Package created successfully!")
        print(f"\nüì¶ Package: {zip_path}")
        print(f"üìä Size: {size_str}")

        print(f"\nüì• Installation:")
        print(f"   unzip {zip_path.name} -d ~/.claude/skills/")

        sys.exit(0)

    except FileNotFoundError as e:
        print(f"‚ùå Error: {e}")
        sys.exit(2)
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(3)


if __name__ == "__main__":
    main()
